/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for user profiles and their associated data,
 *              while allowing public read access to certain collections like 'tournaments' and 'store_items'.
 *              User-specific data (wallets, delivery addresses, videos, notifications) is stored under the /users/{userId} path
 *              and is only accessible to the authenticated user. Other data such as Tournaments, Store Items, Orders, Chat Messages,
 *              Friendships, and Leaderboards are top-level collections, with specific ownership or access control rules.
 *
 * @dataStructure
 * - /users/{userId}: UserProfile data, owned by the user with matching UID.
 * - /users/{userId}/wallet: Wallet data, owned by the user with matching UID.
 * - /users/{userId}/wallet/transactions/{transactionId}: Transaction data, owned by the user with matching UID.
 * - /tournaments/{tournamentId}: Tournament data (publicly readable).
 * - /tournaments/{tournamentId}/matches/{matchId}: Match data (publicly readable).
 * - /participants/{participantId}: Participant data.
 * - /users/{userId}/videos/{videoId}: Video data, owned by the user with matching UID.
 * - /store_items/{storeItemId}: StoreItem data (publicly readable).
 * - /users/{userId}/delivery_addresses/{deliveryAddressId}: DeliveryAddress data, owned by the user with matching UID.
 * - /orders/{orderId}: Order data.
 * - /chat_messages/{chatMessageId}: ChatMessage data.
 * - /friendships/{friendshipId}: Friendship data.
 * - /leaderboards/{leaderboardId}: Leaderboard data.
 * - /leaderboards/{leaderboardId}/entries/{leaderboardEntryId}: LeaderboardEntry data.
 * - /users/{userId}/notifications/{notificationId}: Notification data, owned by the user with matching UID.
 *
 * @keySecurityDecisions
 * - User listing is explicitly denied to protect user privacy.
 * - Data ownership is enforced by matching the authenticated user's UID against the userId in the path and/or document.
 * - Public read access is granted to the 'tournaments' and 'store_items' collections.
 * - Default security posture: Strict ownership. Any ambiguous relationships default to owner-only access.
 *
 * @denormalizationForAuthorization
 * - Wallet and Transaction documents contain a denormalized 'userId' field to simplify authorization checks.
 * - Participant documents contain denormalized 'userId' and 'tournamentId' fields to simplify authorization checks.
 * - DeliveryAddress documents contain a denormalized 'userId' field to simplify authorization checks.
 * - Order documents contain a denormalized 'userId' field to simplify authorization checks.
 * - LeaderboardEntry documents contain a denormalized 'leaderboardId' field to simplify authorization checks.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile data.  Users can only read/write their own profile.
     * @path /users/{userId}
     * @allow (create) User with UID 'user_abc' can create their own profile at /users/user_abc with matching id field.
     * @allow (get) User with UID 'user_abc' can read their own profile at /users/user_abc.
     * @allow (update) User with UID 'user_abc' can update their own profile at /users/user_abc.
     * @allow (delete) User with UID 'user_abc' can delete their own profile at /users/user_abc.
     * @deny (create) User with UID 'user_xyz' cannot create a profile at /users/user_abc.
     * @deny (get) User with UID 'user_xyz' cannot read the profile at /users/user_abc.
     * @deny (update) User with UID 'user_xyz' cannot update the profile at /users/user_abc.
     * @deny (delete) User with UID 'user_xyz' cannot delete the profile at /users/user_abc.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages wallet data for a specific user. Only the user can access their own wallet.
     * @path /users/{userId}/wallet
     * @allow (create) User with UID 'user_abc' can create their own wallet at /users/user_abc/wallet with matching userId field.
     * @allow (get) User with UID 'user_abc' can read their own wallet at /users/user_abc/wallet.
     * @allow (update) User with UID 'user_abc' can update their own wallet at /users/user_abc/wallet.
     * @allow (delete) User with UID 'user_abc' can delete their own wallet at /users/user_abc/wallet.
     * @deny (create) User with UID 'user_xyz' cannot create a wallet at /users/user_abc/wallet.
     * @deny (get) User with UID 'user_xyz' cannot read the wallet at /users/user_abc/wallet.
     * @deny (update) User with UID 'user_xyz' cannot update the wallet at /users/user_abc/wallet.
     * @deny (delete) User with UID 'user_xyz' cannot delete the wallet at /users/user_abc/wallet.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/wallet {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages transaction data for a specific user's wallet. Only the user can access their own transactions.
     * @path /users/{userId}/wallet/transactions/{transactionId}
     * @allow (create) User with UID 'user_abc' can create a transaction at /users/user_abc/wallet/transactions/tx1 with matching userId field in parent wallet.
     * @allow (get) User with UID 'user_abc' can read a transaction at /users/user_abc/wallet/transactions/tx1.
     * @allow (update) User with UID 'user_abc' can update a transaction at /users/user_abc/wallet/transactions/tx1.
     * @allow (delete) User with UID 'user_abc' can delete a transaction at /users/user_abc/wallet/transactions/tx1.
     * @deny (create) User with UID 'user_xyz' cannot create a transaction at /users/user_abc/wallet/transactions/tx1.
     * @deny (get) User with UID 'user_xyz' cannot read the transaction at /users/user_abc/wallet/transactions/tx1.
     * @deny (update) User with UID 'user_xyz' cannot update the transaction at /users/user_abc/wallet/transactions/tx1.
     * @deny (delete) User with UID 'user_xyz' cannot delete the transaction at /users/user_abc/wallet/transactions/tx1.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/wallet/transactions/{transactionId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId); // No userId in transaction, so assuming wallet ownership is sufficient
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to tournament data. Writes are not allowed in this prototype.
     * @path /tournaments/{tournamentId}
     * @allow (get) Any user can read tournament data at /tournaments/tournament1.
     * @allow (list) Any user can list tournaments.
     * @deny (create) No user can create tournaments.
     * @deny (update) No user can update tournaments.
     * @deny (delete) No user can delete tournaments.
     * @principle Grants public read access.
     */
    match /tournaments/{tournamentId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to match data within a tournament. Writes are not allowed in this prototype.
     * @path /tournaments/{tournamentId}/matches/{matchId}
     * @allow (get) Any user can read match data at /tournaments/tournament1/matches/match1.
     * @allow (list) Any user can list matches within a tournament.
     * @deny (create) No user can create matches.
     * @deny (update) No user can update matches.
     * @deny (delete) No user can delete matches.
     * @principle Grants public read access.
     */
    match /tournaments/{tournamentId}/matches/{matchId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages participant data.  In this prototype, any authenticated user can create, update, or delete participant entries.
     *              This should be locked down further in a real application.
     * @path /participants/{participantId}
     */
    match /participants/{participantId} {
      function isSignedIn() {
          return request.auth != null;
      }
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Manages video data for a specific user's channel. Only the user can access their own videos.
     * @path /users/{userId}/videos/{videoId}
     * @allow (create) User with UID 'user_abc' can create their own video at /users/user_abc/videos/video1 with matching channelId field in parent profile.
     * @allow (get) User with UID 'user_abc' can read a video at /users/user_abc/videos/video1.
     * @allow (update) User with UID 'user_abc' can update a video at /users/user_abc/videos/video1.
     * @allow (delete) User with UID 'user_abc' can delete a video at /users/user_abc/videos/video1.
     * @deny (create) User with UID 'user_xyz' cannot create a video at /users/user_abc/videos/video1.
     * @deny (get) User with UID 'user_xyz' cannot read the video at /users/user_abc/videos/video1.
     * @deny (update) User with UID 'user_xyz' cannot update the video at /users/user_abc/videos/video1.
     * @deny (delete) User with UID 'user_xyz' cannot delete the video at /users/user_abc/videos/video1.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/videos/{videoId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId); // No channelId in video, so assuming user id matches profile
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to store item data. Writes are not allowed in this prototype.
     * @path /store_items/{storeItemId}
     * @allow (get) Any user can read store item data at /store_items/item1.
     * @allow (list) Any user can list store items.
     * @deny (create) No user can create store items.
     * @deny (update) No user can update store items.
     * @deny (delete) No user can delete store items.
     * @principle Grants public read access.
     */
    match /store_items/{storeItemId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages delivery address data for a specific user. Only the user can access their own delivery addresses.
     * @path /users/{userId}/delivery_addresses/{deliveryAddressId}
     * @allow (create) User with UID 'user_abc' can create their own delivery address at /users/user_abc/delivery_addresses/address1 with matching userId field.
     * @allow (get) User with UID 'user_abc' can read a delivery address at /users/user_abc/delivery_addresses/address1.
     * @allow (update) User with UID 'user_abc' can update a delivery address at /users/user_abc/delivery_addresses/address1.
     * @allow (delete) User with UID 'user_abc' can delete a delivery address at /users/user_abc/delivery_addresses/address1.
     * @deny (create) User with UID 'user_xyz' cannot create a delivery address at /users/user_abc/delivery_addresses/address1.
     * @deny (get) User with UID 'user_xyz' cannot read the delivery address at /users/user_abc/delivery_addresses/address1.
     * @deny (update) User with UID 'user_xyz' cannot update the delivery address at /users/user_abc/delivery_addresses/address1.
     * @deny (delete) User with UID 'user_xyz' cannot delete the delivery address at /users/user_abc/delivery_addresses/address1.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/delivery_addresses/{deliveryAddressId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages order data.  In this prototype, any authenticated user can create, update, or delete order entries.
     *              This should be locked down further in a real application.
     * @path /orders/{orderId}
     */
    match /orders/{orderId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Manages chat message data.  In this prototype, any authenticated user can create, update, or delete chat message entries.
     *              This should be locked down further in a real application.
     * @path /chat_messages/{chatMessageId}
     */
    match /chat_messages/{chatMessageId} {
      function isSignedIn() {
          return request.auth != null;
      }
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Manages friendship data.  In this prototype, any authenticated user can create, update, or delete friendship entries.
     *              This should be locked down further in a real application.
     * @path /friendships/{friendshipId}
     */
    match /friendships/{friendshipId} {
      function isSignedIn() {
          return request.auth != null;
      }
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Manages leaderboard data.  In this prototype, any authenticated user can create, update, or delete leaderboard entries.
     *              This should be locked down further in a real application.
     * @path /leaderboards/{leaderboardId}
     */
    match /leaderboards/{leaderboardId} {
      function isSignedIn() {
          return request.auth != null;
      }
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Manages leaderboard entry data.  In this prototype, any authenticated user can create, update, or delete leaderboard entries.
     *              This should be locked down further in a real application.
     * @path /leaderboards/{leaderboardId}/entries/{leaderboardEntryId}
     */
    match /leaderboards/{leaderboardId}/entries/{leaderboardEntryId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Manages notification data for a specific user. Only the user can access their own notifications.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (create) User with UID 'user_abc' can create their own notification at /users/user_abc/notifications/notification1 with matching userId field in parent profile.
     * @allow (get) User with UID 'user_abc' can read a notification at /users/user_abc/notifications/notification1.
     * @allow (update) User with UID 'user_abc' can update a notification at /users/user_abc/notifications/notification1.
     * @allow (delete) User with UID 'user_abc' can delete a notification at /users/user_abc/notifications/notification1.
     * @deny (create) User with UID 'user_xyz' cannot create a notification at /users/user_abc/notifications/notification1.
     * @deny (get) User with UID 'user_xyz' cannot read the notification at /users/user_abc/notifications/notification1.
     * @deny (update) User with UID 'user_xyz' cannot update the notification at /users/user_abc/notifications/notification1.
     * @deny (delete) User with UID 'user_xyz' cannot delete the notification at /users/user_abc/notifications/notification1.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/notifications/{notificationId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isExistingOwner(userId);
    }
  }
}